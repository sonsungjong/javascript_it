<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>상속</title>
</head>
<body>
  <script>
    // 상속 : 물려주는거 (class => class)
    // 클래스가 갖고있는거 : 함수와 변수 ==> 함수와 변수를 물려준다
    // 왜 만들었냐? 같은 코드 2번쓰면 2번 수정
    // 같은 코드 5번쓰면 5번 수정해야함...
    class 부모
    {
      constructor(이름, 나이)     // ==> new 할때 ()에 채워줘야함
      {
        this.이름 = 이름      // 매개변수로 받은 이름을 클래스변수에 저장(영구보관)
        this.나이 = 나이      // 매개변수로 받은 나이를 클래스변수에 저장
        // () 또는 {}에서 만든 변수는 탈출하면 삭제 => this. 에다가 백업
        this.종족 = '사람'
      }
      요리하기(){
        console.log(`${this.이름}은(는) 지글지글 요리를 합니다`)
      }

      두발걷기(){
        console.log('일어서서 두발로 걷습니다')
      }
    }

    // 일일히 붙여넣지말고 물려주자 ==> 상속 (컴퓨터 너가 복붙해) extends
    // 상속을 하는 이유 : 일부만 다르게 하려고 (수정 또는 추가)
    class 자식 extends 부모
    {
      constructor(이름, 나이)     // ==> new 할때 ()에 채워줘야함
      {
        // 부모의 것을 사용 super
        super(이름, 나이)     // 부모의 것을 사용
      }
      // extends 를 썻으니깐 보이지는 않지만 위의 코드가 복붙되어있다 가정
      // 근데, 상속을 한 이유는 좀더 추가하거나 수정하기 위해서
      // 추가는 그냥 만들면 됨
      용돈받기(){
        console.log('용돈 주세요')      // 추가는 그냥 만들면 됨
      }

      // 수정(오버라이딩) : 함수의 이름과 매개변수를 그대로 따라하고 내용만 바꿈
      // 요리하기를 지글지글 => 맛있게
      요리하기(){
        //super.요리하기()      // 부모의 요리하기를 사용
        console.log(`${this.이름}은(는) 맛있게 요리합니다`)
      }
    }

    // 사용할때는 변수에 new해서 찍어내서 사용 (객체화)
    var 아빠 = new 부모('나부모', 35);
    var 아들 = new 자식('나자식', 19);

    아빠.요리하기()
    아들.요리하기()

  </script>
</body>
</html>